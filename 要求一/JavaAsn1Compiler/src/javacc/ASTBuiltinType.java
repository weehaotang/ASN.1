package javacc;
/* Generated By:JJTree: Do not edit this line. ASTBuiltinType.java */

import java.io.*;
import java.util.Vector;

public class ASTBuiltinType extends SimpleNode {
	private int builtinType;

	protected static final int INTEGER = 0;
	protected static final int BIT_STRING = 1;
	protected static final int SET = 2;
	protected static final int SEQUENCE = 3;
	protected static final int SET_OF = 4; 
	protected static final int SEQUENCE_OF = 5;
	protected static final int CHOICE = 6;
	protected static final int SELECTION = 7;
	protected static final int TAGGED = 8;
	protected static final int ANY = 9;
	protected static final int ENUM = 10;
	protected static final int OCTET_STRING = 11;
	protected static final int OBJECT_IDENTIFIER = 12;
	protected static final int NULL = 15;

	private static String typeNames[] = {
		"INTEGER",
		"BIT STRING",
		"SET",
		"SEQUNCE",
		"SET OF",
		"SEQUENCE OF",
		"CHOICE",
		"SELECTION",
		"TAGGED",
		"ANY",
		"ENUM",
		"OCTET STRING",
		"OBJECT IDENTIFIER",
		"REAL",
		"BOOLEAN",
		"NULL"
	};

	private static String classNames[] = {
		"ASN1Integer",
		"BitString",
		"Set",
		"Sequence",
		"SetOf",
		"SequenceOf",
		"Choice",
		"SELECTION",
		"???",
		"Any",
		"ENUM",
		"OctetString",
		"ObjectID",
		"REAL",
		"ASN1Boolean",
		"Null"
	};

	protected String
	getClassName()
	{
		if(builtinType != TAGGED)
			return classNames[builtinType];

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getClassName();
		}

		return null;
	}

	protected void
	setType(int type)
	{
		builtinType = type;
	}

	protected String
	getType()
	{
		return typeNames[builtinType];
	}

	/**
	 * Added by Fatih Batuk
	 * <p> to generate Enumerated asn.1 classes in Java
	 * @param enum ASTEnumeratedType
	 * @param name String
	 * @author Fatih Batuk
	 */
	public void generateClassEnum(ASTEnumeratedType enumm, String name)
	{
		try
		{
			String filename = null;
			if(AsnParser.outputDirectory != null)
				filename = new String(AsnParser.outputDirectory + System.getProperty("file.separator") + name + ".java");
			else
				filename = new String(name + ".java");

			OutputStream os = new FileOutputStream(filename);
			String templateName = "myEnum.template";

			BufferedReader reader = new BufferedReader(new FileReader(templateName));
			String line;
			while(true)
			{
				line = reader.readLine();
				if(line == null)
					break;

				int idx = line.indexOf('@');
				while(idx != -1)
				{
					int ndx = line.indexOf('@', idx + 1);
					if(ndx == -1)
						break;

					String directive = line.substring(idx + 1, ndx);
					if(directive.equals("name"))	// replace with the class name
					{
						String left = line.substring(0, idx);
						String right = line.substring(ndx + 1);
						line = new String(left + name + right);
						continue;
					}

					if(directive.equals("package"))	
					{
						if(AsnParser.outputPackage != null)
							line = new String("package " + AsnParser.outputPackage + ";");
						else
							line = "";

						continue;
					}

					if(directive.equals("elements"))	// insert a list of declarations
					{
						
						String[] declarations = getElementDeclarationsEnum(enumm);
						
						for(int i = 0; i < declarations.length; i++)
						{
							os.write(declarations[i].getBytes());
							os.write(0x0a);
							os.flush();
						}
						
						line = "\t/* end of enumerated constants */";
						continue;
					}

				}

				os.write(line.getBytes());
				os.write(0x0a);
				os.flush();
			}
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}

	/**
	 * Added by Fatih Batuk
	 * <p> Creation of elements of the enumerated type
	 * <p>for example : public static final int name = value;
	 * @param et
	 * @return
	 * @author Fatih Batuk
	 */
	private String[]
	getElementDeclarationsEnum(ASTEnumeratedType enumm)
	{
		String eName = "name";
		String eValue = "value";
		
		String dec, dec2;

		Vector<String> decs = new Vector<String>();

		SimpleNode mainNode = (SimpleNode)enumm.jjtGetChild(0);
		
		
		int numChildren = mainNode.jjtGetNumChildren();
		for(int i = 0; i < numChildren; i++)
		{
			SimpleNode element = (SimpleNode)mainNode.jjtGetChild(i);	//take the elements respectively
			SimpleNode nameNode = (SimpleNode)element.jjtGetChild(0);	//element name exists at node 0.
			SimpleNode valueNode = (SimpleNode)element.jjtGetChild(1);	//element value exists at node 1. 
			
			eName = nameNode.first_token.image;
			eName = eName.replace('-', '_'); 
			eValue = valueNode.first_token.image;
			eValue = eValue.replace('-', '_');
					
			dec = new String("\tpublic static final int " + " " + eName + "_ = " + eValue + ";");
			decs.addElement(dec);
			dec2 = new String("\n\tpublic void setTo_"+eName+"_"+eValue+"() {\n\t\tsetValue("+eName+"_);\n\t}\n");
			decs.addElement(dec2);
		}			
		

		if(decs.size() > 0)
		{
			String[] rc = new String[decs.size()];
			decs.toArray(rc);
			return rc;
		}
		
		return null; 
	}
	
	void
	createClass(String name)
	{
		/*
		 * Each of the built in type classes and the defined type class should implement a common interface
		 * that has methods for returning class names and generating classes.
		 *
		 * If done, this method will be trivial.
		 */
		
		//convert '-' signs to '_' sign.	//Added by Fatih Batuk
		name = name.replace('-', '_');		//class name
		
		try
		{
		/*
		 * added by Fatih Batuk : Creation of asn.1 ENUMERATED data types in the asn.1 protocol
		 */	
		if(builtinType == ENUM)
		{ 
			for(int i = 0; i < jjtGetNumChildren(); i++)
			{
				Node node = jjtGetChild(i);
				if(node instanceof ASTEnumeratedType != true)
					continue;
				ASTEnumeratedType et = (ASTEnumeratedType)node;
				generateClassEnum(et,name);
			}
			
		}
			
		if(builtinType == ANY)
		{
			//InputStream is = getClass().getResourceAsStream("any.template");		//modified by Fatih Batuk
			String templateName = "any.template";		//added by Fatih Batuk
			String filename = null;
			if(AsnParser.outputDirectory != null)
				filename = new String(AsnParser.outputDirectory + System.getProperty("file.separator") + name + ".java");
			else
				filename = new String(name + ".java");

			OutputStream os = new FileOutputStream(filename);
			BufferedReader reader = new BufferedReader(new FileReader(templateName));		//modified by Fatih Batuk
			String line;
			while(true)
			{
				line = reader.readLine();
				if(line == null)
					break;

				while(true)
				{
					int idx = line.indexOf('@');
					if(idx == -1)
						break;

					int ndx = line.indexOf('@', idx + 1);	// look for the closing symbol
					if(ndx == -1)
						break;

					String directive = line.substring(idx + 1, ndx);
					if(directive.equals("name"))	// replace with the class name
					{
						String left = line.substring(0, idx);
						String right = line.substring(ndx + 1);
						line = new String(left + name + right);
						continue;
					}

					if(directive.equals("package"))	// insert a list of declarations
					{
						if(AsnParser.outputPackage != null)
							line = new String("package " + AsnParser.outputPackage + ";");
						else
							line = "";

						continue;
					}
				}

				os.write(line.getBytes());
				os.write(0x0a);
			}

			os.flush();
			os.close();
			reader.close();
			return;
		}

		if(builtinType == INTEGER)
		{
			/////////////////////////////////////////////////////////////////////////////////////////////
			/**
			 * Added by Fatih Batuk 
			 * to write INTEGER range constraints like : 
			 * SomeInteger ::= INTEGER {min (0), max (255)} or
			 * MyMinutes ::= INTEGER {first (0), last (59)}
			 * 
			 */
			
			String constraintName, constraintValue, constraint2Name, constraint2Value;
			String elementStringName, elementStringValue;
			Vector<String> declarations = new Vector<String>();
			Vector<String> methodDeclarations = new Vector<String>();
			String[] decs;
			String constructor = "\t\tsuper();";
			int size = -1;
			SimpleNode main = (SimpleNode)jjtGetChild(0);
			
			SimpleNode element, elementName, elementValue;
			
			if (main.jjtGetNumChildren() != 0) {
				
				SimpleNode mainNode = (SimpleNode)main.jjtGetChild(0);
				size = mainNode.jjtGetNumChildren();
				SimpleNode first = (SimpleNode)mainNode.jjtGetChild(0);
				SimpleNode firstName = (SimpleNode)first.jjtGetChild(0);	//MÝN OR MAX OR FIRST OR LAST (one of these)
				SimpleNode firstValue = (SimpleNode)first.jjtGetChild(1);	//Its value (it is some number)
				
				for (int k=0; k<size; k++) {
					element = (SimpleNode)mainNode.jjtGetChild(k);
					elementName = (SimpleNode)element.jjtGetChild(0);	//MÝN OR MAX OR FIRST OR LAST (one of these)
					elementValue= (SimpleNode)element.jjtGetChild(1);	//Its value (it is some number)
					elementStringName = elementName.first_token.image;
					elementStringName = elementStringName.replace('-', '_');
					elementStringValue = elementValue.first_token.image;
					elementStringValue = elementStringValue.replace('-', '_');
					declarations.add (new String ("\tpublic static final long " + " " + elementStringName + " = " + elementStringValue + ";"));
					methodDeclarations.add( new String ( "\tpublic void setTo_"+elementStringName+"_"+elementStringValue+"() {\n\t\tsetValue("+elementStringName+");\n\t}\n"));
				}
				constraintName = firstName.first_token.image;
				constraintName = constraintName.replace('-', '_');
				constraintValue = firstValue.first_token.image;
				constraintValue = constraintValue.replace('-', '_');
				//declarations[0] = "\tpublic static final long " + " " + constraintName + " = " + constraintValue + ";";
				if (size == 1) {
					if (constraintName.equalsIgnoreCase("min") || constraintName.equalsIgnoreCase("first")){
						//declarations[0] += "\n\tsetMin(" + constraintName +");";
						constructor = "\t\tsuper(\"min\"," + constraintName + ");";
					}
					else if (constraintName.equalsIgnoreCase("max") || constraintName.equalsIgnoreCase("last")){
						//declarations[0] += "\n\tsetMax(" + constraintName +");";
						constructor = "\t\tsuper(\"max\"," + constraintName + ");";
					}
				}
				if (size == 2) {
					
					SimpleNode last = (SimpleNode)mainNode.jjtGetChild(1);
					SimpleNode lastName = (SimpleNode)last.jjtGetChild(0);
					SimpleNode lastValue = (SimpleNode)last.jjtGetChild(1);
					constraint2Name = lastName.first_token.image;
					constraint2Name = constraint2Name.replace('-', '_');
					constraint2Value = lastValue.first_token.image;
					constraint2Value = constraint2Value.replace('-', '_');
					//declarations[1] = "\tpublic static final long " + " " + constraint2Name + " = " + constraint2Value + ";";
					
					if (((constraintName.equalsIgnoreCase("min")||constraintName.equalsIgnoreCase("max")) && (constraint2Name.equalsIgnoreCase("max")||constraint2Name.equalsIgnoreCase("min"))) || ((constraintName.equalsIgnoreCase("first")||constraintName.equalsIgnoreCase("last")) && (constraint2Name.equalsIgnoreCase("last")||constraint2Name.equalsIgnoreCase("first"))))  {
						
						if (constraintName.equalsIgnoreCase("min") || constraintName.equalsIgnoreCase("first")){
							//declarations[0] += "\n\tsetMin(" + constraintName +");";
							constructor = "\t\tsuper(\"min\"," + constraintName;
						}
						else if (constraintName.equalsIgnoreCase("max") || constraintName.equalsIgnoreCase("last")){
							//declarations[0] += "\n\tsetMax(" + constraintName +");";
							constructor = "\t\tsuper(\"max\"," + constraintName;
						}
						
						if (constraint2Name.equalsIgnoreCase("min") || constraint2Name.equalsIgnoreCase("first")){
							//declarations[1] += "\n\tsetMin(" + constraint2Name +");";
							constructor += ",\"min\"," + constraint2Name + ");";
						}
						else if (constraint2Name.equalsIgnoreCase("max") || constraint2Name.equalsIgnoreCase("last")){
							//declarations[1] += "\n\tsetMax(" + constraint2Name +");";
							constructor += ",\"max\"," + constraint2Name + ");";
						}
					}
				}
				//else 
					//declarations[1]= " ";
				
				//System.out.println("  ******* SIZE INTEGER is : " + constraintName + " " + constraintValue);
			}
			/*end of checking range constraints*/
			//////////////////////////////////////////////////////////////////////////////////////////////////
				
				
			//InputStream is = getClass().getResourceAsStream("integer.template");		//deleted by Fatih Batuk
			String templateName = "integer.template";		//added by Fatih Batuk
			String filename = null;
			if(AsnParser.outputDirectory != null)
				filename = new String(AsnParser.outputDirectory + System.getProperty("file.separator") + name + ".java");
			else
				filename = new String(name + ".java");

			OutputStream os = new FileOutputStream(filename);
			BufferedReader reader = new BufferedReader(new FileReader(templateName));		//modified by Fatih Batuk
			String line;

			while(true)
			{
				line = reader.readLine();
				if(line == null)
					break;

				while(true)
				{
					int idx = line.indexOf('@');
					if(idx == -1)
						break;

					int ndx = line.indexOf('@', idx + 1);	// look for the closing symbol
					if(ndx == -1)
						break;

					String directive = line.substring(idx + 1, ndx);
					
					if(directive.equals("name"))	// replace with the class name
					{
						String left = line.substring(0, idx);
						String right = line.substring(ndx + 1);
						line = new String(left + name + right);
						continue;
					}

					if(directive.equals("package"))	// insert a list of declarations
					{
						if(AsnParser.outputPackage != null)
							line = new String("package " + AsnParser.outputPackage + ";");
						else
							line = "";

						continue;
					}
					
					if(directive.equals("constraints"))	// added by Fatih Batuk
					{									// to write the integer range constraints
					
						if (size != -1) {
							decs = new String[size];
							declarations.toArray(decs);
							for(int i = 0; i < size; i++)
							{
								os.write(decs[i].getBytes());
								os.write(0x0a);
								os.flush();
							}
							line = "\t/* end of range constraint constants */";
							continue;
						}
						line = "\t/* NO range constraint constants */";
						continue;
					}
					if(directive.equals("methods"))	// added by Fatih Batuk
					{									// to write the integer range constraints
						if (size != -1) {
							decs = new String[size];
							methodDeclarations.toArray(decs);							
							for(int i = 0; i < size; i++)
							{
								os.write(decs[i].getBytes());
								os.write(0x0a);
								os.flush();
							}
							line = "\t/* end of setters */";
							continue;
						}
						line = "\t/* NO setter methods. */";
						continue;
					}
					if(directive.equals("constructor"))	// added by Fatih Batuk
					{									// to write the integer range constraints in constructor
	
						os.write(constructor.getBytes());
						os.flush();
						line = "";
						continue;
					}
					
				}

				os.write(line.getBytes());
				os.write(0x0a);
			}

			os.flush();
			os.close();
			reader.close();
			return;
		}

		if(builtinType == OCTET_STRING)
		{			
			//InputStream is = getClass().getResourceAsStream("octetstring.template");		//modified by Fatih Batuk
			String templateName = "octetstring.template";		//added by Fatih Batuk
			String filename = null;
			if(AsnParser.outputDirectory != null)
				filename = new String(AsnParser.outputDirectory + System.getProperty("file.separator") + name + ".java");
			else
				filename = new String(name + ".java");

			OutputStream os = new FileOutputStream(filename);
			BufferedReader reader = new BufferedReader(new FileReader(templateName));		//modified by Fatih Batuk
			String line;

			while(true)
			{
				line = reader.readLine();
				if(line == null)
					break;

				while(true)
				{
					int idx = line.indexOf('@');
					if(idx == -1)
						break;

					int ndx = line.indexOf('@', idx + 1);	// look for the closing symbol
					if(ndx == -1)
						break;

					String directive = line.substring(idx + 1, ndx);
					if(directive.equals("name"))	// replace with the class name
					{
						String left = line.substring(0, idx);
						String right = line.substring(ndx + 1);
						line = new String(left + name + right);
						continue;
					}

					if(directive.equals("package"))	// insert a list of declarations
					{
						if(AsnParser.outputPackage != null)
							line = new String("package " + AsnParser.outputPackage + ";");
						else
							line = "";

						continue;
					}
				}

				os.write(line.getBytes());
				os.write(0x0a);
			}

			os.flush();
			os.close();
			reader.close();
			return;
		}

		if(builtinType == BIT_STRING)
		{
			for(int i = 0; i < jjtGetNumChildren(); i++)
			{
				Node n = jjtGetChild(i);
				if(n instanceof ASTBitStringType != true)
					continue;

				((ASTBitStringType)n).generateClass(name);
			}

			return;
		}

		if(builtinType == OBJECT_IDENTIFIER)
		{
			for(int i = 0; i < jjtGetNumChildren(); i++)
			{
				Node n = jjtGetChild(i);
				if(n instanceof ASTObjectIdentifierType != true)
					continue;

				((ASTObjectIdentifierType)n).generateClass(name);
			}

			return;
		}
		
		////////////////////////////
		//Added by Fatih Batuk
		if(builtinType == NULL)
		{
			for(int i = 0; i < jjtGetNumChildren(); i++)
			{
				Node n = jjtGetChild(i);
				if(n instanceof ASTNullType != true)
					continue;

				((ASTNullType)n).generateClass(name);
			}

			return;
		}
		/////////////////////////////////
		
		//////////////////////////////
		//added by Fatih Batuk
		if(builtinType == TAGGED)
		{
			// FIXME 
			
			/*
			 * here should be filled correctly if you want to enable creation .java files of TAGGED types like :
			 * 
			 * MyInteger ::= [APPLICATION 5] INTEGER 
			 * or 
			 * MyInteger ::= [5] IMPLICIT INTEGER
			 * 
			 * For this example to enable creation of MyInteger.java class 
			 */
		}
		////////////////////////////////
		
		if(builtinType == SEQUENCE || builtinType == SET)
		{
			for(int i = 0; i < jjtGetNumChildren(); i++)
			{
				Node n = jjtGetChild(i);
				if(n instanceof ASTSetOrSequenceType != true)
					continue;

				((ASTSetOrSequenceType)n).generateClass(name);
			}
		}

		if(builtinType == CHOICE)
		{
			for(int i = 0; i < jjtGetNumChildren(); i++)
			{
				Node n = jjtGetChild(i);
				if(n instanceof ASTChoiceType != true)
					continue;

				((ASTChoiceType)n).generateClass(name);
			}
		}

		if(builtinType == SEQUENCE_OF || builtinType == SET_OF)
		{
			for(int i = 0; i < jjtGetNumChildren(); i++)
			{
				Node n = jjtGetChild(i);
				if(n instanceof ASTSetOrSequenceOfType != true)
					continue;

				((ASTSetOrSequenceOfType)n).generateClass(name);
			}
		}

		}
		catch(IOException e)
		{
			e.printStackTrace();
		}
	}

	public boolean
	isTagged()
	{
		if(builtinType == TAGGED)
			return true;

		return false;
	}

	public int
	getTaggingMethod()
	{
		if(isTagged() != true)
			return 0;	// throw an exception?

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getTaggingMethod();
		}

		return 0;
	}

	public int
	getTagNumber()
	{
		if(isTagged() != true)
			return 0;	// throw an exception?

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getTagNumber();
		}

		return 0;
	}

	public int
	getTagClass()
	{
		if(isTagged() != true)
			return 0;	// throw an exception?

		for(int i = 0; i < jjtGetNumChildren(); i++)
		{
			Node n = jjtGetChild(i);
			if(n instanceof ASTTaggedType != true)
				continue;

			return ((ASTTaggedType)n).getTagClass();
		}

		return ASTTaggedType.CONTEXT;
	}

  public ASTBuiltinType(int id) {
    super(id);
  }

  public ASTBuiltinType(AsnParser p, int id) {
    super(p, id);
  }


  /** Accept the visitor. **/
  public Object jjtAccept(AsnParserVisitor visitor, Object data) {
    return visitor.visit(this, data);
  }
}
